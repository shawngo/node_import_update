<?php
// $Id$

/**
 * @file
 * Update current nodes at node import.
 */

variable_del('niu about to import');
variable_del('niu form post zomg');
variable_del('niu is row[nid] empty');
variable_del('niu nid and vid on import');
variable_del('niu nodeapi');
variable_del('niu_query');
variable_del('niu_where_am_i');


define('NODE_IMPORT_UPDATE_DEBUG', FALSE);

// node_import_update_node_import_values_alter

function node_import_update_node_import_options_alter(&$form, $type, $options, $fields, $map) {
  dpm('is this called now node_import_update_node_import_options_alter');
  dpm(array($map,$form));
  variable_set('node_import_update_map_save', $map);
}

function node_import_update_node_import_values_alter(&$values, $type, $defaults, $options, $fields, $preview) {

  /**
   * this function is called for each of the node import actions. &$values
   * contains the values to be imported into this node.
   *
   * we can then node_load the existing node to get its current values.
   *
   * we have to merge these arrays somehow.
   *
   * $values has new values and nulled values
   *
   * node_load()ed $nodey has all current data.
   *
   * if we had a list of the fields being imported (list_of_fields)
   *  - and based on a (skip | clear) option to either skip the value if new
   *    value is empty - or - clear it from the current node
   *    - skip: the transfer would remove empty fields in list_of_fields
   *    - clear: the transfer would preserve the fields in the list_of_fields
   *
   */

  dpm('we may have a map');
  $map = variable_get('node_import_update_map_save', array());
  dpm(array('orig map' => $map));
  foreach ($map as $map_key => $map_data) {
    /*
     * 1. normal field
     * 2. cck field
     *   a. string
     *   b. array
     * 3. taxonomy
     *   a. array
     *
     * determine what the real key is called and add to map list if not empty
     *
     */
    if (strstr($map_key, 'cck:field_')) {
      if (is_array($map_data)) {
        if (empty($map_data)) {
          unset($map[$map_key]);
        }
        else {
          // cck field not empty, move the name over to $map
          $cck_fieldname = explode(':', $map_key);
          $cck_field = $cck_fieldname[1];
          $map[$cck_field] = $map[$map_key];
        }
      }
      elseif ($map[$map_key] == '') {
        unset($map[$map_key]);
      }
    }
    else {
      if ($map_data == '') {
        unset($map[$map_key]);
      }
    }
  }
  dpm(array('modded map' => $map));
  //variable_set('node_import_update_map_save', $map);

  $nodey = (array) node_load($values['nid']);

  foreach ($map as $key => $val) {
    unset($nodey[$key]);
  }

  
  $values = array_merge($values, (array)$nodey);
  $values['nodey'] = $nodey;
  dpm(array(
    'node_import_update_node_import_values_alter',
    'values' => array(
      'values' => $values,
      'type' => $type,
      'defaults' => $defaults,
      'options' => $options,
      'fields' => $fields,
      'preview' => $preview
    ),
  ));
}

/**
 * Implementation of hook_menu().
 */
function node_import_update_menu() {
  $items = array();
  $items['admin/content/node_import/node_import_update_settings'] = array(
    'title' => 'Node Import Update',
    'description' => 'Update current nodes at import.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_import_update_admin_settings_form'),
    'file' => 'node_import_update.admin.inc',
    'access arguments' => array('administer node import update'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * validation function for Update data using Node Import Update field
 */
function node_import_update_check_validate($element, &$form_state) {
  // set update flag. may have to use a more dynamic / per instance approach
  // since this will affect concurrent node imports
  variable_set('node_import_update_do_update', $element['#value'] == 1);
  dpm(array('validate firing', 'element' => $element, 'new variable is set to' => variable_get('node_import_update_do_update', 'NOT SET')));
}

/**
 * Implementation of hook_form_alter().
 */
function node_import_update_form_alter(&$form, &$form_state, $form_id) {

  // Check if we are walking through the import wizard, add options and overrides.
  if (arg(2) == 'node_import') {

    $values = $form_state['storage'];

    // switch on the different state (page) of the wizard.. unicorns.
    switch ($values['page']) {
      case 'file_options':
        // Add Node Import Update flag to the options settings
        $form['node_import_update_check'] = array(
          '#type' => 'checkbox',
          '#title' => t('Update data using Node Import Update'),
          '#description' => t('Check this option if you want to update the data based on a Field Key'),
          '#default_value' => TRUE,
          '#weight' => 0,
          '#element_validate' => array('node_import_update_check_validate'),
        );
        break;

      // just in case we want to add Misery support or something...
      case 'map':
        break;

      // get the content type immediately after it is set
      case 'options':
        $info_type = explode(':', $form_state['clicked_button']['#post']['map']['node_import_update_unique_key']);
        $data_type = explode(':', $form['#parameters'][1]['storage']['type']);

        // get the content type being updated
        $content_type = $data_type[1];
        $node_import_update_is_cck = $info_type[0] == 'cck';

        // if uc_product enabled, check to see if this is a product
        if (module_exists('uc_product')) {
          $is_product = uc_product_is_product($content_type);
        }

        // set update vars
        variable_set('node_import_update_content_type', $content_type);
        variable_set('node_import_update_is_product', $is_product);
        variable_set('node_import_update_unique_key', $form_state['clicked_button']['#post']['map']['node_import_update_unique_key']);
        variable_set('node_import_update_is_cck', $node_import_update_is_cck);
        
        break;
    }


    /**
     * if form_id == {import_node_type}_node_form, we're either previewing the
     * import or else executing the import update.
     * Search for nodes to update.
     */

    // Node type to be imported
    $import_node_type = variable_get('node_import_update_content_type', '');
    // Settting: update date/time value?
    $import_update_datetime  = variable_get('node_import_update_update_date', TRUE);


    // Alter node edit form
    if ($form_id == $import_node_type .'_node_form') {
      // Import field that holds the unique identifier
      $import_unique_id_name   = variable_get('node_import_update_unique_key', FALSE);
      // Is the identifier a CCK field?
      $import_unique_id_is_cck = variable_get('node_import_update_is_cck', FALSE);

      // flag to determine if we're updating based on the Ubercart model field
      $import_unique_id_is_uc = FALSE;

      // Check if item exists so we can update it rather than importing a new node

      // are we keying off of a cck field?
      if ($import_unique_id_is_cck) {
        // get unique id from cck fields
        $unique_id_value = $form['#post']['cck:field_import_id:value'][0];
        // build query
        $query = 'SELECT c.nid, c.vid FROM {content_type_%s} c WHERE c.%s = "%s"';
      }
      // is this keying off the Ubercart model field?
      elseif ($node_import_update_unique_key == 'model') {
        $import_unique_id_name = 'model';
        // get "unique" id
        $unique_id_value = $form['#post']['model']; // ['cck:field_import_id:value'][0];
        // build query
        $query = 'SELECT u.nid, u.vid FROM {uc_products} u WHERE u.%s = "%s"';
        $import_unique_id_is_uc = TRUE;
      }
      // key is using either nid or node title
      else {
        // get unique id for node values
        $unique_id_value = $form['#post'][$import_unique_id_name];
        // build query
        $query = 'SELECT n.nid, n.vid FROM {node} n WHERE n.type = "%s" AND n.%s = "%s"';
      }

      // Check if we have a unique id
      if ($unique_id_value) {
        // execute query
        // we use a different query if this is keying off of the model field
        if ($import_unique_id_is_uc) {
          $row = db_fetch_array(db_query($query, $import_unique_id_name, $unique_id_value));
        }
        // use cck, node id or title field query
        else {
          $row = db_fetch_array(db_query($query, $import_node_type, $import_unique_id_name, $unique_id_value));
        }

        // Destroy so we don't pass an array on next iteration
        unset($query);

        // If already exists (non empty result)
        if (!empty($row['nid'])) {

          // Set nid and vid to that node
          $form['nid']['#value']= intval($row['nid']);
          $form['vid']['#value']= intval($row['vid']);
          $node = node_load($row['nid'], $row['vid']);
          $form['#node'] = $node;

variable_set('niu insert node', $form);


          // Set time to last updated
          if ($import_update_datetime) {
            $form['changed']['#value'] = time();
          }
          else {
            // create timestamp from string date
            $timestamp = strtotime($form['#post']['changed']);
            // set timestamp value for the below
            $form['changed']['#default_value'] = $timestamp;
          }
        }
      }
    }
  }
}


/**
 * Implementation of hook_node_import_fields() to add the nid field.
 *
 * @param $type string the content type being updated
 * @return array fields array of new fields to add to the form
 */
function node_import_update_node_import_fields ($type) {

  if (!variable_get('node_import_update_do_update', FALSE)) {
    return array();
  }
  // add the Node ID field to use as update key (unique value to search for nodes
  // when executing node import
  $fields = array(
    'nid' => array(
      'title' => 'Node ID',
      'module' => 'node_import_update',
      'weight' => '-1',
      'is_mappable' => TRUE,
      'group' => 'Node Import Update',
    ),
  );
  return $fields;
}


/**
 * Implementation of hook_theme_registry_alter().
 */
function node_import_update_theme_registry_alter(&$theme_registry) {
  if (!empty($theme_registry['node_import_field_table'])) {
    $theme_registry['node_import_field_table']['function'] = 'node_import_update_node_import_field_table';
  }
}


/**
 * Theme the mapping, defaults and options tables.
 *
 * We are overriding this to add the Update key column which is used to select
 * which update key to use as a unique value when searching for nodes to update.
 * 
 */
function node_import_update_node_import_field_table(&$form) {
  $header = $form['#node_import-columns'];
  $rows = array();
  $groups = array();

  // update table/form during "map" page in import wizard
  $map_unique_key = ('map' == $form['#parents'][0]);
  $node_import_update_unique_key = variable_get('node_import_update_unique_key', 'nid');

  if (variable_get('node_import_update_do_update', FALSE) && $map_unique_key) {
    $header [] = 'Update key';
    $niu_unique_default_value = $node_import_update_unique_key;
    $colspan = 3;
  }
  else {
    // use node_import's default table theme function
    return theme_node_import_field_table($form);
  }

  /**
   * loop over the form elements
   */
  dpm(array('this is the form about to be rendered', 'form' => $form, 'form children' => element_children($form)));
  foreach (element_children($form) as $child) {
    if (!isset($form[$child]['#type']) || $form[$child]['#type'] != 'value') {
      $title = check_plain($form[$child]['#title']);
      $group = isset($form[$child]['#node_import-group']) ? $form[$child]['#node_import-group'] : '';
      unset($form[$child]['#title']);

      if (!isset($groups[$group])) {
        $groups[$group] = array();
      }

      /**
       * value in the form of
       *   map[taxonomy:1][]
       *   map[node_import_update_unique_key][taxonomy:1][]
       */

      if ($map_unique_key && unique_qualifier($child)) {
        $return_value = check_plain($child);

        $form['node_import_update_unique_key'][$child] = array(
          '#name' => 'map[node_import_update_unique_key]',
          '#type' => 'radio',
          '#default_value' => $niu_unique_default_value,
          '#return_value' => $return_value,
          '#attributes' => array('align' => 'center'),
        );

        if ($return_value == $niu_unique_default_value) {
          $form['node_import_update_unique_key'][$child]['#attributes']['checked'] = 'checked';
        }

        $element = drupal_render($form['node_import_update_unique_key'][$child]);

      }
      else {
        $element = '';
      }

      $groups[$group][] = array(
        check_plain($title),
        drupal_render($form[$child]),
        $element,
      );
    }
  }

  if (isset($groups['']) && !empty($groups[''])) {
    $rows = array_merge($rows, $groups['']);
  }

  foreach ($groups as $group => $items) {
    if ($group !== '' && !empty($items)) {
      $rows[] = array(
        array('data' => $group, 'colspan' => $colspan, 'class' => 'region'),
      );
      $rows = array_merge($rows, $items);
    }
  }

  if (empty($rows)) {
    $rows[] = array(array('data' => $form['#node_import-empty'], 'colspan' => $colspan));
  }

  return theme('table', $header, $rows) . drupal_render($form);
}

/**
 * determines if the item is a unique field that can be used as a "primary key"
 * of sorts when updating nodes.
 */
function unique_qualifier($item) {
  $unique = array('title', 'model', 'nid');
  $pattern = "/^cck:[a-zA-Z_]+:value$/"; // Example: cck:field_product_text_field:value
  return preg_match($pattern, $item) || in_array($item, $unique);
}

function get_unique_qualifiers() {
  return array('title', 'model', 'nid');
}
// module below ensures existing nodes are updated, to avoid duplication
// kept for the time-being for leagacy sake. May borrow image field handling code, as this remains untested in new code above.
/* function node_import_update_form_product_node_form_alter($data)
{
  $sku = $data['#post']['model'];
  if (is_numeric($sku)){
    $sku = intval($sku) ;
    $row = db_fetch_array(db_query("SELECT uc_products.nid, uc_products.vid, content_field_image_cache.field_image_cache_fid, content_field_image_cache.field_image_cache_list, content_field_image_cache.field_image_cache_data FROM uc_products, content_field_image_cache WHERE uc_products.model = %d AND uc_products.nid = content_field_image_cache.nid LIMIT 1", $sku));
    if (!empty($row)){
      $data['nid']['#value']= intval($row['nid']);
      $data['vid']['#value']= intval($row['vid']);
      $data['#post']['field_image_cache'] = Array(Array('data' => $row['field_image_cache_data'], 'list' => $row['field_image_cache_list'], 'fid' => $row['field_image_cache_fid']));
      $data['#post']['cck:field_image_cache:data'] = $row['field_image_cache_data'];
      $data['#post']['cck:field_image_cache:fid'] = $row['field_image_cache_fid'];
      $data['#post']['cck:field_image_cache:list'] = $row['field_image_cache_list'];
      $data['changed']['#value']= time ();
    }
  }
} */
