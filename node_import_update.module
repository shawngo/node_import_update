<?php
// $Id$

/**
 * @file
 * Update current nodes at node import.
 */

define('NODE_IMPORT_UPDATE_DEBUG', FALSE);

/*
 * drupal_alter for node_import_options
 *
 * preserve the $map values for later
 * 
 */
function node_import_update_node_import_options_alter(&$form, $type, $options, $fields, $map) {
  variable_set('node_import_update_map_save', $map);
}

/*
 * Implementation of hook_node_import_values
 *
 * Create an array of values to submit to the form.
 *
 * @param $type
 *   String. The node_import type.
 *
 * @param $data
 *   Array of data from the file as ($col_index => $value).
 *
 * @param $map
 *   Array of how the data maps to fields.
 *
 * @param $defaults
 *   Array of default values.
 *
 * @param $options
 *   Array of options.
 *
 * @param $fields
 *   Array of available fields.
 *
 * @param $preview
 *   Boolean. If TRUE a preview will be created. If FALSE construct the
 *   values for real.
 *
 * @return
 *   Array of values to submit to a form. See hook_node_import_values().
 */
function node_import_update_node_import_values($type, $defaults, $options, $fields, $preview) {
  /*
  if ($preview) {
    dpm(array('from our new best friend node_import_update_node_import_values',
        '$type' => $type,
        '$data' => $data,
        '$map' => $map,
        '$defaults' => $defaults,
        '$options' => $options,
        '$fields' => $fields,
        'preview' => $preview,
    ));
  }
  */
}

/**
 * this function is called for each of the node import actions. &$values
 * contains the values to be imported into this node.
 *
 * we can then node_load the existing node to get its current values.
 *
 * we have to merge these arrays somehow.
 *
 * $values has new values and nulled values
 *
 * node_load()ed $current_node has all current data.
 *
 * if we had a list of the fields being imported (list_of_fields)
 *  - and based on a (skip | clear) option to either skip the value if new
 *    value is empty - or - clear it from the current node
 *    - skip: the transfer would remove empty fields in list_of_fields
 *    - clear: the transfer would preserve the fields in the list_of_fields
 *
 */
function node_import_update_node_import_values_alter(&$values, $type, $defaults, $options, $fields, $preview) {
  // return if this is a new node
  if ($values['nid'] == '' || !variable_get('node_import_update_do_update', FALSE)) return;

  $current_node = (array) node_load($values['nid']);
  $map = variable_get('node_import_update_map_save', array());
  /*
  dpm(array('values and current_node, together at last (and map!)',
      'current_node' => $current_node,
      'values' => $values,
      'map' => $map,
      'other params',
      'defaults' => $defaults,
      'options' => $options,
      'fields' => $fields,
      'preview' => $preview,
      ));
  // */
  $mapped_taxonomies = array();
  $field_keys = array_keys($fields);
  foreach ($map as $map_key => $map_data) {

    // get rid of fields that aren't being mapped

    // if the map field is empty
    if (!is_array($map_data) && $map_data == '') {
      unset($map[$map_key]);
    }
    elseif (is_array($map_data)) {
      // @TODO if array data is not mapped, kill it too
      //if (strstr($map_key, 'taxonomy:') !== FALSE) {
        // taxonomy field
        if (array_shift($map[$map_key]) == '') {
          unset($map[$map_key]);
        }
        else {
          if (strstr($map_key, 'taxonomy:') !== FALSE) {
            // add mapped taxonomy to a special little cloud in the sky...
            $mapped_taxonomies[] = str_replace('taxonomy:', '', $map_key);
          }
        }
      //}
    }
  }
  // unset our key too
  //unset($map[variable_get('node_import_update_unique_key', '')]);

  dpm(array('new map!', 'map' => $map, 'mapped_taxonomies' => $mapped_taxonomies, 'current node' => $current_node, 'values' => $values));

  // remove all un-mapped $value data - this is to avoid overwriting the current
  // node with default node_import values
  $map_keys = array_keys($map);
  unset($values['created']);


  foreach ($map as $mk => $mv) {
    if (strstr($mk, 'nodewords_')) {
      //echo '<h1>::'. $mv .':: $current_node[nodewords]['. str_replace('nodewords_', '', $mk) .'][value] = '. $values[$mv] .'</h1>';
      $current_node['nodewords'][str_replace('nodewords_', '', $mk)]['value'] = $values[$mk];
      unset($values[$mv]);
    }
  }

  foreach ($values as $vk => $vv) {
    
    if ($vk == 'taxonomy') {
      // we have a taxonomy field - check if it is mapped. if not, unset

      // foreach tags as vid => terms
      foreach ($vv['tags'] as $vocabid => $delimitted_terms) {

        // if it isn't mapped, preserve the taxonomy as an array of comma-
        // separated terms (as they would be form import)
        // preserve stuffs
          $preserved_vocabids = '';
        if (!in_array($vocabid, $mapped_taxonomies)) {
          //$preserved_vocabids[$vocabid] = $content['taxonomy']['tags'][$vocabid];

          
          foreach ($current_node['taxonomy'] as $tid => $tobj) {
            if ($tobj->vid == $vocabid) {

              $preserved_vocabids .= $tobj->name .',';

            }
          }

          $current_node['taxonomy']['tags'][$vocabid] = rtrim($preserved_vocabids, ',');
        }
        else {
          $current_node['taxonomy']['tags'][$vocabid] = $delimitted_terms;

        }
      }
      /*
      foreach ($preserved_vocabids as $vcid => $vcdata) {
        $values['taxonomy']['tags'][$vcid] = $vcdata;
      }
      $current_node['taxonomy'] = $values['taxonomy'];
      */
      unset($values['taxonomy']);

    }
    else {
      /*
       * if the key doesn't exist in current node
       * AND the key doesn't exist in map
       *
       * AND the key cck:{key}:value doesn't exist in map - if the cck field isn't mapped
       * AND it isn't a file list field
       *
       */
      $key_exists_in_node  = array_key_exists($vk, $current_node);
      $key_exists_in_map   = in_array($vk, $map_keys);

      $is_mapped_cck_field = in_array('cck:'. $vk .':fid', $map_keys);
      $is_a_cck_list_field = strstr($vk, ':list') || strstr($vk, ':data');
  /*
      $map = map keys

      $values = has some creative shit, mang

      $current_node = the current node
  */
      // keep it if it is some sort of extraneous cck field (eg. :list) TODO add to this list?

      if (!($is_mapped_cck_field || $is_a_cck_list_field)) {
        if (false) echo '<h3>fooing '. $vk .'</h1>';
        if ($key_exists_in_node && !$key_exists_in_map) {
          unset($values[$vk]);
        }
      }
      else if (strstr($vk, ':data')) {
        if (false) echo '<h3>fooingx '. $vk .'</h1>';
        // TODO check for multiple fields
        $cck_name_data = explode(':', $vk);

        $values[$vk] = $current_node[$cck_name_data[1]][0]['data'];
        
      }
      else if ($is_mapped_cck_field) {
        // TODO add support for image / file info (alt & title)
        // need to copy keys from $values to $current_node to import fields
        $current_node[$vk] = $values[$vk];
        if (false) echo '<h1>resetting cck field: '. $vk .'</h1>';
      }
    }

/*
    if ((!array_key_exists($vk, $current_node) && !in_array($vk, $map_keys)) && !in_array('cck:'. $vk .':value', $map_keys) && !strstr($vk, ':list')) {// && $vk != 'taxonomy') {
      unset($values[$vk]);
      
      //dpm(array('unsetting' => $values[$vk]));
    }
*/
  }
//dpm(array('values before foreach' => $values, $current_node));
  foreach ($values as $v_key => $v_value) {
    //if (array_key_exists($cn_key, $values)) {
      $current_node[$v_key] = $v_value;
    //}
  }



  // these jerks wouldn't move over...
  $current_node['dim_length'] = $current_node['length'];
  $current_node['dim_width']  = $current_node['width'];
  $current_node['dim_height'] = $current_node['height'];

  $values = $current_node;//array_merge($current_node, $values);
  dpm(array('VALUES TO IMPORT' => $values));
return;



  //dpm(array('orig map' => $map, $values, $type, $defaults, $options, $fields));
  
  

  

  

  foreach ($map as $map_key => $map_data) {
    /*
     * 1. normal field
     * 2. cck field
     *   a. string
     *   b. array
     * 3. taxonomy
     *   a. array
     *
     * values = values to be imported
     * current_node  = the existing node data
     *
     * we need= values to have all the correct data
     *
     * we get there by:
     *   - removing the data values in $current_node that will be overwritten by import
     *   - adding $current_node data to $values that we want to preserve
     *   - array_merge remaining $current_node values into $values
     *
     *   so - flag is CLEAR FIELDS or SKIP FIELDS if importing value is empty
     *
     * determine what the real key is called and add to map list if not empty
     *
     */
    $mpdta = is_array($values[$map_key]) ? 'is an array' : $values[$map_key];

    // if we have a cck field it's probably an array
    // @TODO do we really need to bug cck:field ?
    if (strstr($map_key, 'cck:field_')) {
      if (is_array($map_data)) {
        // if it isn't mapped, remove it from our map
        if (empty($map_data)) {
          unset($map[$map_key]);
        }
        else {
          // cck field not empty, move the name over to $map
          $cck_fieldname = explode(':', $map_key);
          $cck_field = $cck_fieldname[1];

          $values[$cck_field] = array($map[$map_key]);
          $current_node[$cck_field]  = array($map[$map_key]);

          $values[$cck_field][0]['value'] = $values[$cck_field];
          //$current_node[$cck_field]  = array($map[$map_key]);
          unset($current_node[$cck_field]);
        }
      }
      elseif ($map[$map_key] == '') {
        unset($map[$map_key]);
      }
      else {
        echo '<h1 style="color:pink">we dont have anything for this case yet</h1>';
        $values[$map_key] = $current_node[$map_key];
        unset($current_node[$map_key]);
      }
    }
    else {
      // if map_data is blank then we should kill this field otherwise our data
      // will get overwritten

      if ($map_data == '') {
        //
        echo '<h1>-- map data is empty and not a cck:field ****'. $map_key .'****</h1>';
        unset($map[$map_key]);
        unset($current_node[$key]);
      }
      if (is_array($map_data)) {
        echo '<h1 style="color:#f00">things</h1>';
        $values[$map_key][0]['value'] = $current_node[$map_key];
        unset($current_node[$map_key]);
      }
      else {
        echo '<h1>-- map data is NOT empty: '. $current_node[$map_key] .'</h1>';
        $values[$map_key] = $current_node[$map_key];
        unset($current_node[$map_key]);
      }
    }
    
  }
  //dpm(array('modded map' => $map));

  // merge values of the current node that we want to preserve
  $values = array_merge($values, $current_node);



  dpm(array('values after array_merge current_node', 'values' => $values, 'current_node' => $current_node));//, 'map' => $map));
  $values['current_node'] = $current_node;
/*
  dpm(array(

    'node_import_update_node_import_values_alter',
    'values' => array(
      'values' => $values,
      'type' => $type,
      'defaults' => $defaults,
      'options' => $options,
      'fields' => $fields,
      'preview' => $preview
    ),
  ));
*/
  
}

/**
 * Implementation of hook_menu().
 */
function node_import_update_menu() {
  $items = array();
  $items['admin/content/node_import/node_import_update_settings'] = array(
    'title' => 'Node Import Update',
    'description' => 'Update current nodes at import.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_import_update_admin_settings_form'),
    'file' => 'node_import_update.admin.inc',
    'access arguments' => array('administer node import update'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Validation function for Update data using Node Import Update field
 *
 * Set update flag. may have to use a more dynamic / per instance approach
 * since this will affect concurrent node imports.
 *
 * This is being set like this because it is picked up in our implementation of
 * hook_node_import_fields($type) to add radio buttons on the map page (step 4).
 *
 */
function node_import_update_check_validate($element, &$form_state) {
  // set the do upate variable based on our checkbox #value
  variable_set('node_import_update_do_update', $element['#value'] == 1);
  //dpm(array('validate firing', 'element' => $element, 'new variable is set to' => variable_get('node_import_update_do_update', 'NOT SET')));
}

/**
 * Implementation of hook_form_alter().
 */
function node_import_update_form_alter(&$form, &$form_state, $form_id) {

  // Check if we are walking through the import wizard, add options and overrides.
  if (arg(2) == 'node_import') {

    $values = $form_state['storage'];

    // switch on the different state (page) of the wizard.. unicorns.
    switch ($values['page']) {
      case 'file_options':
        // Add Node Import Update flag to the options settings
        $form['node_import_update_check'] = array(
          '#type' => 'checkbox',
          '#title' => t('Update data using Node Import Update'),
          '#description' => t('Check this option if you want to update the data based on a Field Key'),
          '#default_value' => $values['node_import_update_check'],
          '#weight' => 0,
          '#element_validate' => array('node_import_update_check_validate'),
        );
        break;

      // just in case we want to add Misery support or something...
      case 'map':
        // add validation handler for
        $form['#validate'][] = 'node_import_update_unique_value_check';
        break;

      // get the content type immediately after it is set
      case 'options':
        $info_type = explode(':', $form_state['clicked_button']['#post']['map']['node_import_update_unique_key']);
        $data_type = explode(':', $form['#parameters'][1]['storage']['type']);

        // get the content type being updated
        $content_type = $data_type[1];
        $node_import_update_is_cck = $info_type[0] == 'cck';

        // if uc_product enabled, check to see if this is a product
        if (module_exists('uc_product')) {
          $is_product = uc_product_is_product($content_type);
        }

        // set update vars
        variable_set('node_import_update_content_type', $content_type);
        variable_set('node_import_update_unique_key', $form_state['clicked_button']['#post']['map']['node_import_update_unique_key']);
        variable_set('node_import_update_is_cck', $node_import_update_is_cck);
        
        break;

      case 'preview':
        //dpm(array('PREEVEUUUUE', $form, $form_state, $form_id));
        break;
      
      case 'start':
        // add a notice to the preview page
        $niu_options = array(
          '#type' => 'item',
          '#title' => 'Node import update options',
          '#value' => '<p><strong>WARNING:</strong> You are about to update a bunch of content and <strong>possibly destroy stuff</strong>. Just an FYI.</p>',
        );
        array_unshift($form, $niu_options);
        break;
    }


    /**
     * if form_id == {import_node_type}_node_form, we're either previewing the
     * import or else executing the import update.
     * Search for nodes to update.
     */

    // Node type to be imported
    $import_node_type = variable_get('node_import_update_content_type', '');
    // Settting: update date/time value?
    $import_update_datetime  = variable_get('node_import_update_update_date', TRUE);



    // Alter node edit form
    if ($form_id == $import_node_type .'_node_form') {
      // Import field that holds the unique identifier
      $import_unique_id_name   = variable_get('node_import_update_unique_key', FALSE);
      // Is the identifier a CCK field?
      $import_unique_id_is_cck = variable_get('node_import_update_is_cck', FALSE);

      // flag to determine if we're updating based on the Ubercart model field
      $import_unique_id_is_uc = FALSE;

      // Check if item exists so we can update it rather than importing a new node

      // are we keying off of a cck field?
      if ($import_unique_id_is_cck) {
        // get unique id from cck fields
        $unique_id_value = $form['#post']['cck:field_import_id:value'][0];
        // build query
        $query = 'SELECT c.nid, c.vid FROM {content_type_%s} c WHERE c.%s = "%s"';
      }
      // is this keying off the Ubercart model field?
      elseif ($import_unique_id_name == 'model') {
        $import_unique_id_name = 'model';
        // get "unique" id
        $unique_id_value = $form['#post']['model']; // ['cck:field_import_id:value'][0];
        // build query
        $query = 'SELECT u.nid, u.vid FROM {uc_products} u WHERE u.%s = "%s"';
        $import_unique_id_is_uc = TRUE;
      }
      // key is using either nid or node title
      else {
        // get unique id for node values
        $unique_id_value = $form['#post'][$import_unique_id_name];
        // build query
        $query = 'SELECT n.nid, n.vid FROM {node} n WHERE n.type = "%s" AND n.%s = "%s"';
      }
dpm(array('$import_unique_id_name' => $import_unique_id_name, 'query' => $query, '$import_unique_id_is_uc' => $import_unique_id_is_uc));
      // Check if we have a unique id
      if ($unique_id_value) {
        // execute query
        // we use a different query if this is keying off of the model field
        if ($import_unique_id_is_uc) {
          $row = db_fetch_array(db_query($query, $import_unique_id_name, $unique_id_value));
        }
        // use cck, node id or title field query
        else {
          $row = db_fetch_array(db_query($query, $import_node_type, $import_unique_id_name, $unique_id_value));
        }

        // Destroy so we don't pass an array on next iteration
        unset($query);

        // If already exists (non empty result)
        if (!empty($row['nid'])) {

          // Set nid and vid to that node
          $form['nid']['#value']= intval($row['nid']);
          $form['vid']['#value']= intval($row['vid']);
          $node = node_load($row['nid'], $row['vid']);
          $form['#node'] = $node;

          // Set time to last updated
          if ($import_update_datetime) {
            $form['changed']['#value'] = time();
          }
          else {
            // create timestamp from string date
            $timestamp = strtotime($form['#post']['changed']);
            // set timestamp value for the below
            $form['changed']['#default_value'] = $timestamp;
          }
        }
      }
    }
  }
}


/**
 * Implementation of hook_node_import_fields() to add the nid field.
 *
 * @param $type string the content type being updated
 * @return array fields array of new fields to add to the form
 */
function node_import_update_node_import_fields ($type) {

  if (!variable_get('node_import_update_do_update', FALSE)) {
    return array();
  }
  // add the Node ID field to use as update key (unique value to search for nodes
  // when executing node import
  $fields = array(
    'nid' => array(
      'title' => 'Node ID',
      'module' => 'node_import_update',
      'weight' => '-1',
      'is_mappable' => TRUE,
      'group' => 'Node Import Update',
    ),
  );
  return $fields;
}


/**
 * Implementation of hook_theme_registry_alter().
 */
function node_import_update_theme_registry_alter(&$theme_registry) {
  if (!empty($theme_registry['node_import_field_table'])) {
    $theme_registry['node_import_field_table']['function'] = 'node_import_update_node_import_field_table';
  }
}


/**
 * Theme the mapping, defaults and options tables.
 *
 * We are overriding this to add the Update key column which is used to select
 * which update key to use as a unique value when searching for nodes to update.
 * 
 */
function node_import_update_node_import_field_table(&$form) {
  $header = $form['#node_import-columns'];
  $rows = array();
  $groups = array();

  // update table/form during "map" page in import wizard
  $map_unique_key = ('map' == $form['#parents'][0]);
  $node_import_update_unique_key = variable_get('node_import_update_unique_key', 'nid');

  if (variable_get('node_import_update_do_update', FALSE) && $map_unique_key) {
    $header [] = 'Update key';
    $niu_unique_default_value = $node_import_update_unique_key;
    $colspan = 3;
  }
  else {
    // use node_import's default table theme function
    return theme_node_import_field_table($form);
  }

  /**
   * loop over the form elements
   */
   //$form['node_import_update_unique_key']['#element_validate'] = array('node_import_update_unique_key_validate');
  dpm(array('this is the form about to be rendered', 'form' => $form, 'form children' => element_children($form)));

  foreach (element_children($form) as $child) {
    if (!isset($form[$child]['#type']) || $form[$child]['#type'] != 'value') {
      $title = check_plain($form[$child]['#title']);
      $group = isset($form[$child]['#node_import-group']) ? $form[$child]['#node_import-group'] : '';
      unset($form[$child]['#title']);

      if (!isset($groups[$group])) {
        $groups[$group] = array();
      }

      /**
       * value in the form of
       *   map[taxonomy:1][]
       *   map[node_import_update_unique_key][taxonomy:1][]
       */

      if ($map_unique_key && unique_qualifier($child)) {
        // add radio buttons for unique keys
        $form['node_import_update_unique_key'][$child] = array(
          '#name' => 'map[node_import_update_unique_key]',
          '#type' => 'radio',
          '#return_value' => $child,
          '#attributes' => array('align' => 'center'),
        );
        //if ($niu_unique_default_value == $return_value) {
          //$form['node_import_update_unique_key'][$child]['#default_value'] = $niu_unique_default_value;
        //}
        dpm(array($niu_unique_default_value, $child, $child));

        if ($child == $niu_unique_default_value) {
          $form['node_import_update_unique_key'][$child]['#attributes']['checked'] = 'checked';
        }

        $element = drupal_render($form['node_import_update_unique_key'][$child]);

      }
      else {
        $element = '';
      }

      $groups[$group][] = array(
        check_plain($title),
        drupal_render($form[$child]),
        $element,
      );
    }
  }

  if (isset($groups['']) && !empty($groups[''])) {
    $rows = array_merge($rows, $groups['']);
  }

  foreach ($groups as $group => $items) {
    if ($group !== '' && !empty($items)) {
      $rows[] = array(
        array('data' => $group, 'colspan' => $colspan, 'class' => 'region'),
      );
      $rows = array_merge($rows, $items);
    }
  }

  if (empty($rows)) {
    $rows[] = array(array('data' => $form['#node_import-empty'], 'colspan' => $colspan));
  }

  return theme('table', $header, $rows) . drupal_render($form);
}

function node_import_update_unique_value_check($form, &$form_state) {
  
  // @TODO decide whether to keep this in storage
  $form_state['storage']['node_import_update_unique_key'] = $form_state['clicked_button']['#post']['map']['node_import_update_unique_key'];
  variable_set('node_import_update_unique_key', $form_state['storage']['node_import_update_unique_key']);

  // dpm (array('node_import_update_unique_value_check', 'form' => $form, 'form_state' => $form_state, 'a'));
}

/**
 * Validation function for radio button on the map page
 *
 * Set update flag. may have to use a more dynamic / per instance approach
 * since this will affect concurrent node imports.
 *
 * This is being set like this because it is picked up in our implementation of
 * hook_node_import_fields($type) to add radio buttons on the map page (step 4).
 *
 */
function node_import_update_unique_key_validate($element, &$form_state) {
  // set the do upate variable based on our checkbox #value
  //variable_set('node_import_update_do_update', $element['#value'] == 1);
  dpm('KEY VALIDATE FUNCTION');
  dpm(array('validate firing KEY VALIDATE', 'element' => $element, 'new variable is set to' => variable_get('node_import_update_do_update', 'NOT SET')));
}

/**
 * Determines if the item is a unique field that can be used as a "primary key"
 * of sorts when updating nodes.
 */
function unique_qualifier($item) {
  $unique = array('title', 'model', 'nid');
  $pattern = "/^cck:[a-zA-Z_]+:value$/"; // Example: cck:field_product_text_field:value
  return preg_match($pattern, $item) || in_array($item, $unique);
}


if (module_exists('nodewords_basic')) {
  function nodewords_node_import_fields($type) {
    $fields = array();
    $weight = 1;
    if (variable_get('nodewords_edit_metatags_' . $type, TRUE)) {
      $xfields = nodewords_basic_nodewords_tags_info();
      foreach ($xfields as $key => $field_data) {
        $fields['nodewords_'. $key] = array(
          'title' => t($field_data['widget:label']),
          'group' => t('Meta data'),
          'weight' => ++$weight,
        );
      }
    }
    return $fields;
  }
}



// module below ensures existing nodes are updated, to avoid duplication
// kept for the time-being for leagacy sake. May borrow image field handling code, as this remains untested in new code above.
/* function node_import_update_form_product_node_form_alter($data)
{
  $sku = $data['#post']['model'];
  if (is_numeric($sku)){
    $sku = intval($sku) ;
    $row = db_fetch_array(db_query("SELECT uc_products.nid, uc_products.vid, content_field_image_cache.field_image_cache_fid, content_field_image_cache.field_image_cache_list, content_field_image_cache.field_image_cache_data FROM uc_products, content_field_image_cache WHERE uc_products.model = %d AND uc_products.nid = content_field_image_cache.nid LIMIT 1", $sku));
    if (!empty($row)){
      $data['nid']['#value']= intval($row['nid']);
      $data['vid']['#value']= intval($row['vid']);
      $data['#post']['field_image_cache'] = Array(Array('data' => $row['field_image_cache_data'], 'list' => $row['field_image_cache_list'], 'fid' => $row['field_image_cache_fid']));
      $data['#post']['cck:field_image_cache:data'] = $row['field_image_cache_data'];
      $data['#post']['cck:field_image_cache:fid'] = $row['field_image_cache_fid'];
      $data['#post']['cck:field_image_cache:list'] = $row['field_image_cache_list'];
      $data['changed']['#value']= time ();
    }
  }
} */
